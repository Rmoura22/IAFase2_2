#|
Implementa√ß√£o dos m√©todos de procura e com a implementa√ß√£o das m√©tricas de
an√°lise de efici√™ncia, i.e. a parte do programa que √© independente do dom√≠nio de aplica√ß√£o
N√≥ - (pontos posCavalo tabela profundidade pai heuristica)
|#

(defpackage "Algorithms")

;(bfs1 (no-teste2) 'issolution (get-operators))
(defun BFS1 (root pred operators objective)
 ""
 ;openList - Lista de abertos
 ;closedList - Lista de fechados
 ;sucs - Sucessores, √© atualizado em BFS-rec
 ;solution - Resultado da fun√ß√£o any, se nil ent√£o ainda n√£o encontrou solu√ß√£o
  (let* ((openList (list root)) (closedList nil) (sucs nil) (solution nil))
   (labels (
    (BFS-rec ()
     (cond 
      ((null openList) "This shit aint work")
      ;((node-exists (car openList) closedList 'bfs) ())
      (t
        (setf sucs (remove-if #'null (funcall 'successors (car openList) operators)))
        (setf solution (any pred sucs objective))
        (cons (car openList) closedList)
        (setf openList (appendToOpenList sucs (cdr openList) closedList 'bfs))
        (if solution 
         solution 
         (BFS-rec)
        )
      )
     )
    ))
   (BFS-rec)
   )
  ) 
)

;(bfs2 (no-teste2) 'issolution 'successors (get-operators))
(defun BFS (root pred sucFunc operators objective &optional (openList (list root)) (closedList nil))
  (cond 
      ;Se lita de abertos vazia falha
   ((null openList) "No Solution found :(((")
   ; Gerar sucessores e verificar se algum √© solu√ß√£o
   (t (let* ((sucs (funcall sucFunc (car openList) operators)) (solution (any pred sucs objective)))
        (cond   
           ;Se algum √© solu√ß√£o retorna      
         ((not (null solution)) (list solution openList closedList))
           ;Se n√£o encontrou solu√ß√£o adiciona os sucessores a lista de abertos e repete
         (t (BFS root pred sucFunc operators objective (append (cdr openList) sucs) (cons (car openList) closedList)))
         )
        )
      )
   )
)

;(dfs (no-teste2) 'issolution 'successors (get-operators) :maxDepth 40)
(defun DFS (root pred sucFunc operators objective &optional (openList (list root)) (closedList nil) (maxDepth 10))
  (cond 
      ;Se lita de abertos vazia falha
   ((null openList) "No Solution found :(((")
   ; Gerar sucessores e verificar se algum √© solu√ß√£o
   (t (let* ((sucs (funcall sucFunc (car openList) operators maxDepth)) (solution (any pred sucs)))
        (cond   
           ;Se algum √© solu√ß√£o retorna      
         ((not (null solution)) solution)
           ;Se n√£o encontrou solu√ß√£o adiciona os sucessores ao inicio da lista de abertos e repete
         (t (DFS root pred sucFunc operators objective (append sucs (cdr openList)) (cons (car openList) closedList)))
        )
      )
   )
  )
)

;(a-star (no-teste2) 'issolution 'successors (get-operators) 'calcheuristic)
(defun A-Star (root predFunc sucFunc operators heuristicFunc objective &optional (openList (list root)) (closedList nil))
 (cond
  ((null openList) "Keine L√∂sung gefunden")
  (t (let* ((sucs (funcall sucFunc (car openList) operators 100 heuristicfunc)) (solution (any predFunc sucs)))

       (cond   
           ;Se algum √© solu√ß√£o retorna      
         ((not (null solution)) solution)
           ;Se n√£o encontrou solu√ß√£o adiciona os sucessores ao inicio da lista de abertos e repete
         (t (A-Star root predFunc sucFunc operators heuristicfunc (appendToOpenList sucs (cdr openList) (cons (car openList) closedList) 'aStar) (cons (car openList) closedList)))
        )
      )
  )
 )
)

(defun insertOrderedDecHeuristic (Node Nodes)
 (cond 
  ((null Nodes) (list Node))
  ((< (sixth Node) (sixth (car Nodes))) (cons Node Nodes))
  (t (cons (first Nodes) (insertOrderedDecHeuristic Node (cdr Nodes))))
 )
)

(defun appendToOpenList (sucs openList closedList alg)
 (cond 
  ((null sucs) openList)
  ((node-exists (car sucs) closedList alg) (appendToOpenList (cdr sucs) openList closedList alg))
  ((equal alg 'aStar) 
   (insertOrderedDecHeuristic (car sucs) (appendToOpenList (cdr sucs) openList closedList alg))
  )
  ((equal alg 'bfs)
   (append (appendToOpenList (cdr sucs) openList closedList alg) (list(car sucs)))
  )
  ((equal alg 'dfs)
   (cons (car sucs) (appendToOpenList (cdr sucs) openList closedList alg))
  )
 )
)

(defun calcHeuristic (node objective)
  (append (subseq node 0 5) (list(heuristic1 node objective)))
)


(defun any (pred lista objective)
 (cond
  ((null lista) nil)
  ((funcall pred  (car lista) objective) (car lista))
  (t (any pred (cdr lista) objective))
 )
)

(defun node-exists (node nodes alg)
"Returns t if the give node exists in the nodes list otherwise nil"
 (cond 
  ((null nodes) nil)

  ((equal alg 'bfs)
   (cond 
    ((equal (third node) (third (first nodes))) t)
    (t (node-exists node (cdr nodes) alg))
   )
  )

  ((equal alg 'dfs)
   (cond 
    ((and (> (fourth node) (fourth (first nodes))) (equal (third node) (third (first nodes)))) t)
    (t (node-exists node (cdr nodes) alg))
   )  )
 )
)

(defun isSolution (node objective)
 (>= (first node) objective)
)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;; FASE2  ;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;
;;;; Constantes:
;;;;


(defvar *maximum-value* 10000)
(defvar *minimum-value* -10000)

;; NÛ -  (pontos1 pontos2 position1 table profundidade curJogador pai heuristica position2)

;(minmax (no-teste5) 2 *jogador1*)
;(minmax (no-teste5) 3 *jogador1*)
(defun minmax (node profundidade-max jogador-max)
  (let (( result (cond 
    ((or (eq (fifth node) profundidade-max) 
         (null (successors node (get-operators) profundidade-max nil)))               ;NÛ raiz ou folha
                            (cons (heuristic-minmax node) (list node)))  ; (cons node (heuristic-minmax node)))   (heuristic-minmax node))
    (t (let ((sucessores (successors node (get-operators) profundidade-max nil)))
                         (cond
                           ((eq (sixth node) jogador-max)                             ;NÛ Max
                                (minmax-max sucessores profundidade-max jogador-max))   
                           (t                                                         ;NÛ Min
                                (minmax-min sucessores profundidade-max jogador-max))   
                         )
       )
    )                                         
  )))
  (format t "Profundidade: ~A~%" (fifth node))
  (format t "Jogador: ~A~%" (sixth node))
  (format t "PontuaÁ„o1: ~A~%" (first node))
  (format t "PontuaÁ„o2: ~A~%" (second node))
  (format t "HeurÌstica: ~A~%" (heuristic-minmax node))
  (format t "Melhor NÛ: ~A~%" *jogada*)
  (format t "Pai: ~A~%" (seventh node))
  (format t "\n")
  (printTable (fourth node))
  result)
)

(defun minmax-test (function)
  (format t "Resultado: ~A~%" function)
  (format t "Melhor NÛ: ~A~%" *jogada*)
  (format t "Melhor NÛ: ~A~%" *melhor-no*)
)


(defun minmax-max (sucessores profundidade-max jogador-max)
  (let ((result (max-value-recursive sucessores profundidade-max jogador-max (cons most-negative-fixnum (list nil)))))
    (setf *jogada* (second result))
    result)); (cdr result)


(defun max-value-recursive (sucessores profundidade-max jogador-max current-max-pair)
  (if (null sucessores)
      current-max-pair
      (let ((child-result (minmax (first sucessores) profundidade-max jogador-max))
             (profundidade (fifth (first sucessores)))) ;varri·vel para teste
        (if (>= (first child-result) (first current-max-pair))
            (max-value-recursive (rest sucessores) profundidade-max jogador-max child-result)
            (max-value-recursive (rest sucessores) profundidade-max jogador-max current-max-pair)))))


(defun minmax-min (sucessores profundidade-max jogador-max)
  (let ((result (min-value-recursive sucessores profundidade-max jogador-max (cons most-positive-fixnum (list nil)))))
    (setf *jogada* (second result))
    result )) ; (cdr result)


(defun min-value-recursive (sucessores profundidade-max jogador-max current-min-pair)
  (if (null sucessores)
      current-min-pair
      (let ((child-result (minmax (first sucessores) profundidade-max jogador-max))
            (profundidade (fifth (first sucessores)))) ;vari·vel para teste)
        (if (<= (first child-result) (first current-min-pair))
            (min-value-recursive (rest sucessores) profundidade-max jogador-max child-result)
            (min-value-recursive (rest sucessores) profundidade-max jogador-max current-min-pair)))))

#|

(defun minmax-max (sucessores profundidade-max jogador-max)
  (max-value-recursive sucessores profundidade-max jogador-max *minimum-value*))

(defun max-value-recursive (sucessores profundidade-max jogador-max current-max)
  (if (null sucessores)
      current-max
      (let ((child-value (minmax (first sucessores) profundidade-max (not jogador-max))))
        (max-value-recursive (rest sucessores) profundidade-max jogador-max (max child-value current-max)))))

(defun minmax-min (sucessores profundidade-max jogador-max)
  (min-value-recursive sucessores profundidade-max jogador-max *maximum-value*))

(defun min-value-recursive (sucessores profundidade-max jogador-max current-min)
  (if (null sucessores)
      current-min
      (let ((child-value (minmax (first sucessores) profundidade-max (not jogador-max))))
        (min-value-recursive (rest sucessores) profundidade-max jogador-max (min child-value current-min)))))

|#
;(defun minmax-max (sucessores profundidade-max jogador-max)
;  ()
;)

;(defun minmax-min (sucessores profundidade-max jogador-max))





#|
 ******************** Tests ********************
|#


(defun printTable (table)
  (cond 
   ((null table) (format t "~%"))
   (t (printList (car table)) (printTable (cdr table)))
  )
)


(defun printList (lista)
  (cond
   ((null lista) (format t "~%~%"))
   (t (if (null (car lista)) (format t " -- ") (format t " ~2,' d " (car lista))) (printList (cdr lista)))
  )
)