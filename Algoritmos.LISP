#|
Implementa√ß√£o dos m√©todos de procura e com a implementa√ß√£o das m√©tricas de
an√°lise de efici√™ncia, i.e. a parte do programa que √© independente do dom√≠nio de aplica√ß√£o
N√≥ - (pontos posCavalo tabela profundidade pai heuristica)
|#

(defpackage "Algorithms")

;(bfs1 (no-teste2) 'issolution (get-operators))
(defun BFS1 (root pred operators objective)
 ""
 ;openList - Lista de abertos
 ;closedList - Lista de fechados
 ;sucs - Sucessores, √© atualizado em BFS-rec
 ;solution - Resultado da fun√ß√£o any, se nil ent√£o ainda n√£o encontrou solu√ß√£o
  (let* ((openList (list root)) (closedList nil) (sucs nil) (solution nil))
   (labels (
    (BFS-rec ()
     (cond 
      ((null openList) "This shit aint work")
      ;((node-exists (car openList) closedList 'bfs) ())
      (t
        (setf sucs (remove-if #'null (funcall 'successors (car openList) operators)))
        (setf solution (any pred sucs objective))
        (cons (car openList) closedList)
        (setf openList (appendToOpenList sucs (cdr openList) closedList 'bfs))
        (if solution 
         solution 
         (BFS-rec)
        )
      )
     )
    ))
   (BFS-rec)
   )
  ) 
)

;(bfs2 (no-teste2) 'issolution 'successors (get-operators))
(defun BFS (root pred sucFunc operators objective &optional (openList (list root)) (closedList nil))
  (cond 
      ;Se lita de abertos vazia falha
   ((null openList) "No Solution found :(((")
   ; Gerar sucessores e verificar se algum √© solu√ß√£o
   (t (let* ((sucs (funcall sucFunc (car openList) operators)) (solution (any pred sucs objective)))
        (cond   
           ;Se algum √© solu√ß√£o retorna      
         ((not (null solution)) (list solution openList closedList))
           ;Se n√£o encontrou solu√ß√£o adiciona os sucessores a lista de abertos e repete
         (t (BFS root pred sucFunc operators objective (append (cdr openList) sucs) (cons (car openList) closedList)))
         )
        )
      )
   )
)

;(dfs (no-teste2) 'issolution 'successors (get-operators) :maxDepth 40)
(defun DFS (root pred sucFunc operators objective &optional (openList (list root)) (closedList nil) (maxDepth 10))
  (cond 
      ;Se lita de abertos vazia falha
   ((null openList) "No Solution found :(((")
   ; Gerar sucessores e verificar se algum √© solu√ß√£o
   (t (let* ((sucs (funcall sucFunc (car openList) operators maxDepth)) (solution (any pred sucs)))
        (cond   
           ;Se algum √© solu√ß√£o retorna      
         ((not (null solution)) solution)
           ;Se n√£o encontrou solu√ß√£o adiciona os sucessores ao inicio da lista de abertos e repete
         (t (DFS root pred sucFunc operators objective (append sucs (cdr openList)) (cons (car openList) closedList)))
        )
      )
   )
  )
)

;(a-star (no-teste2) 'issolution 'successors (get-operators) 'calcheuristic)
(defun A-Star (root predFunc sucFunc operators heuristicFunc objective &optional (openList (list root)) (closedList nil))
 (cond
  ((null openList) "Keine L√∂sung gefunden")
  (t (let* ((sucs (funcall sucFunc (car openList) operators 100 heuristicfunc)) (solution (any predFunc sucs)))

       (cond   
           ;Se algum √© solu√ß√£o retorna      
         ((not (null solution)) solution)
           ;Se n√£o encontrou solu√ß√£o adiciona os sucessores ao inicio da lista de abertos e repete
         (t (A-Star root predFunc sucFunc operators heuristicfunc (appendToOpenList sucs (cdr openList) (cons (car openList) closedList) 'aStar) (cons (car openList) closedList)))
        )
      )
  )
 )
)

(defun insertOrderedDecHeuristic (Node Nodes)
 (cond 
  ((null Nodes) (list Node))
  ((< (sixth Node) (sixth (car Nodes))) (cons Node Nodes))
  (t (cons (first Nodes) (insertOrderedDecHeuristic Node (cdr Nodes))))
 )
)

(defun appendToOpenList (sucs openList closedList alg)
 (cond 
  ((null sucs) openList)
  ((node-exists (car sucs) closedList alg) (appendToOpenList (cdr sucs) openList closedList alg))
  ((equal alg 'aStar) 
   (insertOrderedDecHeuristic (car sucs) (appendToOpenList (cdr sucs) openList closedList alg))
  )
  ((equal alg 'bfs)
   (append (appendToOpenList (cdr sucs) openList closedList alg) (list(car sucs)))
  )
  ((equal alg 'dfs)
   (cons (car sucs) (appendToOpenList (cdr sucs) openList closedList alg))
  )
 )
)

(defun calcHeuristic (node objective)
  (append (subseq node 0 5) (list(heuristic1 node objective)))
)


(defun any (pred lista objective)
 (cond
  ((null lista) nil)
  ((funcall pred  (car lista) objective) (car lista))
  (t (any pred (cdr lista) objective))
 )
)

(defun node-exists (node nodes alg)
"Returns t if the give node exists in the nodes list otherwise nil"
 (cond 
  ((null nodes) nil)

  ((equal alg 'bfs)
   (cond 
    ((equal (third node) (third (first nodes))) t)
    (t (node-exists node (cdr nodes) alg))
   )
  )

  ((equal alg 'dfs)
   (cond 
    ((and (> (fourth node) (fourth (first nodes))) (equal (third node) (third (first nodes)))) t)
    (t (node-exists node (cdr nodes) alg))
   )  )
 )
)

(defun isSolution (node objective)
 (>= (first node) objective)
)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;; FASE2  ;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;
;;;; Constantes:
;;;;


(defvar *maximum-value* 10000)
(defvar *minimum-value* -10000)


;; NÛ -  (pontos1 pontos2 position1 table profundidade curJogador pai heuristica position2)

;(minmax (no-teste5) 2 *jogador1*)
;(minmax (no-teste5) 3 *jogador1*)

(defun minmax (node profundidade-max jogador-max)
  (format t "Profundidade: ~A~%" (fifth node))
  (format t "Jogador: ~A~%" (sixth node))
  (format t "PontuaÁ„o1: ~A~%" (first node))
  (format t "PontuaÁ„o2: ~A~%" (second node))
  (format t "HeurÌstica: ~A~%" (heuristic-minmax node))
  (format t "Melhor NÛ: ~A~%" *jogada*)
  (format t "Pai: ~A~%" (seventh node))
  (format t "\n")
  (printTable (fourth node))
  (let ((result (cond 
    ((or (eq (fifth node) profundidade-max) 
         (null (successors node (get-operators) profundidade-max nil)))               ;NÛ raiz ou folha
                            (heuristic-minmax node))  ; (cons node (heuristic-minmax node)))   (heuristic-minmax node))
    (t (let ((sucessores (successors node (get-operators) profundidade-max nil)))
                         (cond
                           ((eq (sixth node) jogador-max)                             ;NÛ Max
                                (minmax-max sucessores profundidade-max jogador-max))   
                           (t                                                         ;NÛ Min
                                (minmax-min sucessores profundidade-max jogador-max))))))))
  
  result)
)

;(minmax-test (minmax (no-teste5) 3 *jogador1*))
(defun minmax-test (function)
  (format t "Resultado: ~A~%" function)
  (format t "Melhor NÛ: ~A~%" *jogada*)
  (format t "Cortes Alfa: ~A~%" *cortes-alfa*)
  (format t "Cortes Beta: ~A~%" *cortes-beta*)
)


(defun minmax-max (sucessores profundidade-max jogador-max)
  (max-value-recursive sucessores profundidade-max jogador-max most-negative-fixnum)); (cdr result)


(defun max-value-recursive (sucessores profundidade-max jogador-max current-max)
  (if (null sucessores)
      current-max
      (let ((child-result (minmax (first sucessores) profundidade-max jogador-max))
             (profundidade (fifth (first sucessores)))) ;varri·vel para teste
        (cond 
          ((>= child-result current-max) 
           (max-value-recursive (rest sucessores) profundidade-max jogador-max child-result))
          (t 
           (setf *jogada* (first sucessores))
           (min-value-recursive (rest sucessores) profundidade-max jogador-max current-max))))))


(defun minmax-min (sucessores profundidade-max jogador-max)
  (min-value-recursive sucessores profundidade-max jogador-max most-positive-fixnum)) ; (cdr result)


(defun min-value-recursive (sucessores profundidade-max jogador-max current-min)
  (if (null sucessores)
      current-min
      (let ((child-result (minmax (first sucessores) profundidade-max jogador-max))
            (profundidade (fifth (first sucessores)))) ;vari·vel para teste)
        (cond 
          ((<= child-result current-min) 
           (min-value-recursive (rest sucessores) profundidade-max jogador-max child-result))
          (t 
           (setf *jogada* (first sucessores))
           (min-value-recursive (rest sucessores) profundidade-max jogador-max current-min))))))




;(alfa-beta (no-teste5) 3 *jogador1*)
(defun alfa-beta (node profundidade-max jogador-max timestamps &optional (alfa *minimum-value*) (beta *maximum-value*) (stats '(0 0 0 0 0)))
  (format t "Profundidade: ~A~%" (fifth node))
  (format t "Jogador: ~A~%" (sixth node))
  (format t "PontuaÁ„o1: ~A~%" (first node))
  (format t "PontuaÁ„o2: ~A~%" (second node))
  (format t "HeurÌstica: ~A~%" (heuristic-minmax node))
  (format t "Melhor NÛ: ~A~%" *jogada*)
  (format t "Pai: ~A~%" (seventh node))
  (format t "NÛs gerados: ~A~%" (first stats))
  (format t "NÛs expandidos: ~A~%" (second stats))
  (format t "NÛs avaliados: ~A~%" (third stats))
  (format t "NÛs cortes-alfa: ~A~%" (fourth stats))
  (format t "NÛs cortes-beta: ~A~%" (fifth stats))
  (printTable (fourth node))
  (format t "\n")
  (let* ((result (cond
    ((or (eq (fifth node) profundidade-max)
         (null node) 
         (null (successors node (get-operators) profundidade-max nil))
         (has-passed-90-percent (first timestamps) (second timestamps)))               ;NÛ raiz ou folha
                            (heuristic-minmax node))  ; (cons node (heuristic-minmax node)))   (heuristic-minmax node))
    (t (let ((sucessores (order-nodes (successors node (get-operators) profundidade-max nil) (sixth node) jogador-max))) ; (ordenar (|# successors node (get-operators) profundidade-max nil #|) (sixth node) jogador-max)
                         
                         (cond
                           ((eq (sixth node) jogador-max)                             ;NÛ Max
                                (alfa-beta-max sucessores profundidade-max 
                                               jogador-max timestamps alfa beta (update-stats stats '(0 1 0 0 0))))   
                           (t                                                         ;NÛ Min
                                (alfa-beta-min sucessores profundidade-max 
                                               jogador-max timestamps alfa beta (update-stats stats '(0 1 0 0 0))))))
  ))))
  
  result)
)

;;Caso de nÛ MAX
;;FunÁ„o retorna alfa se n„o houverem sucessores, 
;;com sucessores a funÁ„o verifica o m·ximo entre beta e o valor alfa do sucessor
;;corta o ramo se beta for menor, caso contr·rio continua a seguir o ramo
(defun alfa-beta-max (sucessores profundidade-max jogador-max timestamps alfa beta stats)
  (if (null sucessores)
      alfa
      (let* ((child-result (alfa-beta (first sucessores) profundidade-max jogador-max timestamps alfa beta stats))
             (profundidade (fifth (first sucessores))) ;varri·vel para teste
             (novo-alfa (max alfa child-result)))
        (cond 
          ((> novo-alfa beta) 
              (setf *cortes-alfa* (+ *cortes-alfa* 1))
              (update-stats stats '(0 0 0 1 0))
              beta)
          (t 
           (setf *jogada* (first sucessores))
           (max novo-alfa (alfa-beta-max (rest sucessores) profundidade-max 
                                          jogador-max timestamps novo-alfa beta (update-stats stats '(0 0 1 0 0))))))))
)


;;Caso de nÛ MIN
;;FunÁ„o retorna beta se n„o houverem sucessores, 
;;com sucessores a funÁ„o verifica o mÌnimo entre alfa e o valor beta do sucessor
;;corta o ramo se alfa for maior, caso contr·rio continua a seguir o ramo
(defun alfa-beta-min (sucessores profundidade-max jogador-max timestamps alfa beta stats)
  (if (null sucessores)
       beta 
       (let* ((child-result (alfa-beta (first sucessores) profundidade-max jogador-max timestamps alfa beta stats))
             (profundidade (fifth (first sucessores))) ;varri·vel para teste
             (novo-beta (min beta child-result)))
         (cond 
           ((< novo-beta alfa)  
               (setf *cortes-beta* (+ *cortes-beta* 1))
               (update-stats stats '(0 0 0 0 1))    
               alfa)
           (t  
            (setf *jogada* (first sucessores))
            (min novo-beta (alfa-beta-min (rest sucessores) profundidade-max 
                                           jogador-max timestamps alfa novo-beta (update-stats stats '(0 0 1 0 0))))))))
)



;(alfa-beta-test (alfa-beta (no-teste5) 2 *jogador1*))
;(alfa-beta-test (alfa-beta (no-teste5) 3 *jogador1* (list (get-internal-real-time) 5000))); 5 segundos
(defun alfa-beta-test (function)
  (format t "Resultado: ~A~%" function)
  (format t "Melhor NÛ: ~A~%" *jogada*)
  (format t "NÛs cortes-alfa: ~A~%" *cortes-alfa*)
  (format t "NÛs cortes-beta: ~A~%" *cortes-beta*)
  (setf *cortes-alfa* 0)
  (setf *cortes-beta* 0)
)


#|
 ******************** Statistics ********************
|#

; stats: (nos-gerados nos-expandidos nos-avaliados cortes-alfa cortes-beta)
(defun update-stats (stats values)
  (mapcar #'(lambda (s v) (+ s v)) stats values)
)

(defun has-passed-90-percent (startTimestamp timeLimit)
  "Check if at least 90% of the time has passed since the start timestamp."
  (let* ((currentTime (get-internal-real-time)))
    (>= (- currentTime startTimestamp) (* 0.9 timeLimit))
  )
)

(defun order-nodes (nodes jogador-max jogador)
  (cond
    ((eq jogador-max jogador) (max-node-sort nodes))
    (t (min-node-sort nodes))
  )
)

(defun max-node-sort (nodes)
  "Retorna uma lista de nÛs ordenados por heuristica decrescente"
  (cond
    ((null nodes) nil)
    (t (let* ((min-node (find-min-node nodes))
           (rest-nodes (remove min-node nodes)))
      (append  (list min-node) (max-node-sort rest-nodes)
             ))))
)

(defun find-max-node (nodes)
  "Encontra o nÛ com melhor heuristica na lista de nÛs"
  (reduce #'(lambda (a b)
              (if (> (heuristic-minmax a) (heuristic-minmax b))
                a
                b))
          nodes)
)


(defun min-node-sort (nodes)
  "Retorna uma lista de nÛs ordenados por heuristica crescente"
  (cond
    ((null nodes) nil)
    (t (let* ((max-node (find-max-node nodes))
           (rest-nodes (remove max-node nodes)))
      (append  (list max-node) (min-node-sort rest-nodes)
             ))))
)

(defun find-min-node (nodes)
  "Encontra o nÛ com pior heuristica na lista de nÛs"
  (reduce #'(lambda (a b)
              (if (< (heuristic-minmax a) (heuristic-minmax b))
                a
                b))
          nodes)
)



#|
 ******************** Tests ********************
|#


(defun printTable (table)
  (cond 
   ((null table) (format t "~%"))
   (t (printList (car table)) (printTable (cdr table)))
  )
)


(defun printList (lista)
  (cond
   ((null lista) (format t "~%~%"))
   (t (if (null (car lista)) (format t " -- ") (format t " ~2,' d " (car lista))) (printList (cdr lista)))
  )
)